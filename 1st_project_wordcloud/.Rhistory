function (formula, data = NULL, ..., subset, na.action = na.omit, scale = TRUE)
{
call <- match.call()
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
m <- match.call(expand.dots = FALSE)
if (identical(class(eval.parent(m$data)), "matrix"))
m$data <- as.data.frame(eval.parent(m$data))
m$... <- NULL
m$scale <- NULL
m[[1L]] <- quote(stats::model.frame)
m$na.action <- na.action
m <- eval(m, parent.frame())
Terms <- attr(m, "terms")
attr(Terms, "intercept") <- 0
x <- model.matrix(Terms, m)
y <- model.extract(m, "response")
attr(x, "na.action") <- attr(y, "na.action") <- attr(m, "na.action")
if (length(scale) == 1)
scale <- rep(scale, ncol(x))
if (any(scale)) {
remove <- unique(c(which(labels(Terms) %in%
names(attr(x, "contrasts"))),
which(!scale)
)
)
scale <- !attr(x, "assign") %in% remove
}
ret <- svm.default (x, y, scale = scale, ..., na.action = na.action)
ret$call <- call
ret$call[[1]] <- as.name("svm")
ret$terms <- Terms
if (!is.null(attr(m, "na.action")))
ret$na.action <- attr(m, "na.action")
class(ret) <- c("svm.formula", class(ret))
return (ret)
}
svm.default <-
function (x,
y           = NULL,
scale       = TRUE,
type        = NULL,
kernel      = "radial",
degree      = 3,
gamma       = if (is.vector(x)) 1 else 1 / ncol(x),
coef0       = 0,
cost        = 1,
nu          = 0.5,
class.weights = NULL,
cachesize   = 40,
tolerance   = 0.001,
epsilon     = 0.1,
shrinking   = TRUE,
cross       = 0,
probability = FALSE,
fitted      = TRUE,
...,
subset,
na.action = na.omit)
svm.default <-
function (x,
y           = NULL,
scale       = TRUE,
type        = NULL,
kernel      = "radial",
degree      = 3,
gamma       = if (is.vector(x)) 1 else 1 / ncol(x),
coef0       = 0,
cost        = 1,
nu          = 0.5,
class.weights = NULL,
cachesize   = 40,
tolerance   = 0.001,
epsilon     = 0.1,
shrinking   = TRUE,
cross       = 0,
probability = FALSE,
fitted      = TRUE,
...,
subset,
na.action = na.omit)
{
yorig <- y
if(inherits(x, "Matrix")) {
loadNamespace("SparseM")
loadNamespace("Matrix")
x <- as(x, "matrix.csr")
}
if(inherits(x, "simple_triplet_matrix")) {
loadNamespace("SparseM")
ind <- order(x$i, x$j)
x <- new("matrix.csr",
ra = x$v[ind],
ja = x$j[ind],
ia = as.integer(cumsum(c(1, tabulate(x$i[ind])))),
dimension = c(x$nrow, x$ncol))
}
if (sparse <- inherits(x, "matrix.csr"))
loadNamespace("SparseM")
## NULL parameters?
if(is.null(degree)) stop(sQuote("degree"), " must not be NULL!")
if(is.null(gamma)) stop(sQuote("gamma"), " must not be NULL!")
if(is.null(coef0)) stop(sQuote("coef0"), " must not be NULL!")
if(is.null(cost)) stop(sQuote("cost"), " must not be NULL!")
if(is.null(nu)) stop(sQuote("nu"), " must not be NULL!")
if(is.null(epsilon)) stop(sQuote("epsilon"), " must not be NULL!")
if(is.null(tolerance)) stop(sQuote("tolerance"), " must not be NULL!")
xhold   <- if (fitted) x else NULL
x.scale <- y.scale <- NULL
formula <- inherits(x, "svm.formula")
## determine model type
if (is.null(type)) type <-
if (is.null(y)) "one-classification"
else if (is.factor(y)) "C-classification"
else "eps-regression"
type <- pmatch(type, c("C-classification",
"nu-classification",
"one-classification",
"eps-regression",
"nu-regression"), 99) - 1
if (type > 10) stop("wrong type specification!")
kernel <- pmatch(kernel, c("linear",
"polynomial",
"radial",
"sigmoid"), 99) - 1
if (kernel > 10) stop("wrong kernel specification!")
nac <- attr(x, "na.action")
## scaling, subsetting, and NA handling
if (sparse) {
scale <- rep(FALSE, ncol(x))
if(!is.null(y)) na.fail(y)
x <- SparseM::t(SparseM::t(x)) ## make shure that col-indices are sorted
} else {
x <- as.matrix(x)
## subsetting and na-handling for matrices
if (!formula) {
if (!missing(subset)) {
x <- x[subset,]
y <- y[subset]
if (!is.null(xhold))
xhold <- as.matrix(xhold)[subset,]
}
if (is.null(y))
x <- na.action(x)
else {
df <- na.action(data.frame(y, x))
y <- df[,1]
x <- as.matrix(df[,-1], rownames.force = TRUE)
nac <-
attr(x, "na.action") <-
attr(y, "na.action") <-
attr(df, "na.action")
}
}
## scaling
if (length(scale) == 1)
scale <- rep(scale, ncol(x))
if (any(scale)) {
co <- !apply(x[,scale, drop = FALSE], 2, var)
if (any(co)) {
warning(paste("Variable(s)",
paste(sQuote(colnames(x[,scale,
drop = FALSE])[co]),
sep="", collapse=" and "),
"constant. Cannot scale data.")
)
scale <- rep(FALSE, ncol(x))
} else {
xtmp <- scale(x[,scale])
x[,scale] <- xtmp
x.scale <- attributes(xtmp)[c("scaled:center","scaled:scale")]
if (is.numeric(y) && (type > 2)) {
yorig <- y
y <- scale(y)
y.scale <- attributes(y)[c("scaled:center","scaled:scale")]
y <- as.vector(y)
}
}
}
}
## further parameter checks
nr <- nrow(x)
if (cross > nr)
stop(sQuote("cross"), " cannot exceed the number of observations!")
ytmp <- y
attributes(ytmp) <- NULL
if (!is.vector(ytmp) && !is.factor(y) && type != 2)
stop("y must be a vector or a factor.")
if (type != 2 && length(y) != nr)
stop("x and y don't match.")
if (cachesize < 0.1)
cachesize <- 0.1
if (type > 2 && !is.numeric(y))
stop("Need numeric dependent variable for regression.")
lev <- NULL
weightlabels <- NULL
## in case of classification: transform factors into integers
if (type == 2) # one class classification --> set dummy
y <- rep(1, nr)
else
if (is.factor(y)) {
lev <- levels(y)
y <- as.integer(y)
} else {
if (type < 3) {
if(any(as.integer(y) != y))
stop("dependent variable has to be of factor or integer type for classification mode.")
y <- as.factor(y)
lev <- levels(y)
y <- as.integer(y)
} else lev <- unique(y)
}
if (type < 3 && !is.null(class.weights)) {
if (is.null(names(class.weights)))
stop("Weights have to be specified along with their according level names !")
weightlabels <- match (names(class.weights), lev)
if (any(is.na(weightlabels)))
stop("At least one level name is missing or misspelled.")
}
nclass <- 2
if (type < 2) nclass <- length(lev)
if (type > 1 && length(class.weights) > 0) {
class.weights <- NULL
warning(sQuote("class.weights"), " are set to NULL for regression mode. For classification, use a _factor_ for ", sQuote("y"),
", or specify the correct ", sQuote("type"), " argument.")
}
err <- empty_string <- paste(rep(" ", 255), collapse = "")
if (is.null(type)) stop("type argument must not be NULL!")
if (is.null(kernel)) stop("kernel argument must not be NULL!")
if (is.null(degree)) stop("degree argument must not be NULL!")
if (is.null(gamma)) stop("gamma argument must not be NULL!")
if (is.null(coef0)) stop("coef0 seed argument must not be NULL!")
if (is.null(cost)) stop("cost argument must not be NULL!")
if (is.null(nu)) stop("nu argument must not be NULL!")
if (is.null(cachesize)) stop("cachesize argument must not be NULL!")
if (is.null(tolerance)) stop("tolerance argument must not be NULL!")
if (is.null(epsilon)) stop("epsilon argument must not be NULL!")
if (is.null(shrinking)) stop("shrinking argument must not be NULL!")
if (is.null(cross)) stop("cross argument must not be NULL!")
if (is.null(sparse)) stop("sparse argument must not be NULL!")
if (is.null(probability)) stop("probability argument must not be NULL!")
cret <- .C (R_svmtrain,
## data
as.double  (if (sparse) x@ra else t(x)),
as.integer (nr), as.integer(ncol(x)),
as.double  (y),
## sparse index info
as.integer (if (sparse) x@ia else 0),
as.integer (if (sparse) x@ja else 0),
## parameters
as.integer (type),
as.integer (kernel),
as.integer (degree),
as.double  (gamma),
as.double  (coef0),
as.double  (cost),
as.double  (nu),
as.integer (weightlabels),
as.double  (class.weights),
as.integer (length (class.weights)),
as.double  (cachesize),
as.double  (tolerance),
as.double  (epsilon),
as.integer (shrinking),
as.integer (cross),
as.integer (sparse),
as.integer (probability),
## results
nclasses = integer  (1),
nr       = integer  (1), # nr of support vectors
index    = integer  (nr),
labels   = integer  (nclass),
nSV      = integer  (nclass),
rho      = double   (nclass * (nclass - 1) / 2),
coefs    = double   (nr * (nclass - 1)),
sigma    = double   (1),
probA    = double   (nclass * (nclass - 1) / 2),
probB    = double   (nclass * (nclass - 1) / 2),
cresults = double   (cross),
ctotal1  = double   (1),
ctotal2  = double   (1),
error    = err
)
if (cret$error != empty_string)
stop(paste(cret$error, "!", sep=""))
cret$index <- cret$index[1:cret$nr]
ret <- list (
call     = match.call(),
type     = type,
kernel   = kernel,
cost     = cost,
degree   = degree,
gamma    = gamma,
coef0    = coef0,
nu       = nu,
epsilon  = epsilon,
sparse   = sparse,
scaled   = scale,
x.scale  = x.scale,
y.scale  = y.scale,
nclasses = cret$nclasses, #number of classes
levels   = lev,
tot.nSV  = cret$nr, #total number of sv
nSV      = cret$nSV[1:cret$nclasses], #number of SV in diff. classes
labels   = cret$labels[1:cret$nclasses], #labels of the SVs.
SV       = if (sparse) SparseM::t(SparseM::t(x[cret$index]))
else t(t(x[cret$index,,drop = FALSE])), #copy of SV
index    = cret$index,  #indexes of sv in x
##constants in decision functions
rho      = cret$rho[1:(cret$nclasses * (cret$nclasses - 1) / 2)],
##probabilites
compprob = probability,
probA    = if (!probability) NULL else
cret$probA[1:(cret$nclasses * (cret$nclasses - 1) / 2)],
probB    = if (!probability) NULL else
cret$probB[1:(cret$nclasses * (cret$nclasses - 1) / 2)],
sigma    = if (probability) cret$sigma else NULL,
##coefficiants of sv
coefs    = if (cret$nr == 0) NULL else
t(matrix(cret$coefs[1:((cret$nclasses - 1) * cret$nr)],
nrow = cret$nclasses - 1,
byrow = TRUE)),
na.action = nac
)
## cross-validation-results
if (cross > 0)
if (type > 2) {
scale.factor     <- if (any(scale)) crossprod(y.scale$"scaled:scale") else 1;
ret$MSE          <- cret$cresults * scale.factor;
ret$tot.MSE      <- cret$ctotal1  * scale.factor;
ret$scorrcoeff   <- cret$ctotal2;
} else {
ret$accuracies   <- cret$cresults;
ret$tot.accuracy <- cret$ctotal1;
}
class (ret) <- "svm"
if (fitted) {
ret$fitted <- na.action(predict(ret, xhold,
decision.values = TRUE))
ret$decision.values <- attr(ret$fitted, "decision.values")
attr(ret$fitted, "decision.values") <- NULL
if (type > 1) ret$residuals <- yorig - ret$fitted
}
ret
}
x = matrix(rnorm(100*100), 100)
y = c(rep(1,50), rep(-1,50)
)
svm.formula(x ,y)
a = svm.formula(x ,y)
a = svm.default(x ,y)
a
load("C:/Users/young/Desktop/Simulation/Script/Cancer/No4/cancer_result_alon_1.Rdata")
Cancer_result$K_Output_klr$K_piResult
library(CVST); library(kernrank); library(datamicroarray); library(caret)
install.packages("CVST")
install.packages("CVST")
install.packages("datamicroarray")
install.packages("Quandl")
library(Quandl)
gold = Quandl('LBMA/GOLD', start_date="2015-01-01", end_date="2018-12-31")
View(gold)
length(gold$`USD (AM)`)
silver = Quandl('LBMA/SILVER', start_date='2015-01-01', end_date='2018-12-31')
View(silver)
platinum = Quandl('JOHNMATT/PLAT', start_date='2015-01-01', end_date='2018-12-31')
platinum = Quandl('JOHNMATT / PLAT', start_date='2015-01-01', end_date='2018-12-31')
platinum = Quandl('LPPM/PLAT', start_date='2015-01-01', end_date='2018-12-31')
class(silver)
platinum = Quandl('LPPM/PLAT', start_date='2015-01-01', end_date='2015-06-30')
View(gold)
rm(list=ls())
a= c(2,6,24,120,720,5040,12,60,36,2520,20160,20,120,840,6720,30,210,1680,15120,42,336,3024,30240,56,504,5040,72,720)
b = sort(a)
b
a= c(2,6,24,120,720,5040,12,60,360,2520,20160,20,120,840,6720,30,210,1680,15120,42,336,3024,30240,56,504,5040,72,720)
b = sort(a)
b
a+ b
for(i in 1:100){
a = c(a, i!)
}
for(i in 1:100){
a = c(a, i*(i+1))
a = c(a, i*(i+1)*(i+2))
a = c(a, i*(i+1)*(i+2)*(i+3))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7)*(i+8))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7)*(i+8)*(i+9))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7)*(i+8)*(i+9)*(i+10))
}
a = c()
for(i in 1:100){
a = c(a, i*(i+1))
a = c(a, i*(i+1)*(i+2))
a = c(a, i*(i+1)*(i+2)*(i+3))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7)*(i+8))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7)*(i+8)*(i+9))
a = c(a, i*(i+1)*(i+2)*(i+3)*(i+4)*(i+5)*(i+6)*(i+7)*(i+8)*(i+9)*(i+10))
}
b = sort(a)
b
unique(b)
c=unique(b)
c
12*13
13*14
99*100
14*15
15*16
16*17
17*18
tmp = matrix(0, 1000,1000)
a1 = 1:1000
for(i in 1:1000){
if(i == 1) a_tmp = a1*(a1+i)
else{
a_tmp = a_tmp = a_tmp*(a_tmp+i)
}
tmp[i,] = a_tmp
}
for(i in 1:1000){
if(i == 1) a_tmp = a1*(a1+i)
else{
a_tmp = a_tmp*(a_tmp+i)
}
tmp[i,] = a_tmp
}
for(i in 1:1000){
if(i == 1) a_tmp = a1*(a1+i)
else{
a_tmp = a_tmp*(a1+i)
}
tmp[i,] = a_tmp
}
for(i in 1:500){
if(i == 1) a_tmp = a1*(a1+i)
else{
a_tmp = a_tmp*(a1+i)
}
tmp[i,] = a_tmp
}
View(tmp)
a1 = 1:1000
tmp = matrix(0, 1000,1000)
for(i in 1:1000){
if(i == 1) a_tmp = a1*(a1+i)
else{
a_tmp = a_tmp*(a1+i)
}
tmp[i,] = a_tmp
}
max(tmp)
sort(tmp)
View(tmp)
setwd("C:/Users/young/Desktop/news")
library(shiny)
library(memoise)
library(tm)
library(stringr)
library(rJava)
library(SnowballC)
library(wordcloud)
library(KoNLP)
# 방송사
broadcasts = list("sbs", "jtbc", "ytn")
getAnalResult = memoise(function(broadcast, year){
if(!(broadcast %in% broadcasts))
stop("Unkown book")
cast_location = paste0("C:/Users/young/Desktop/news/", broadcast)
cast_list = list.files(cast_location)
cast_data = data.frame()
for(file in cast_list){
temp = read.csv(paste0(cast_location,"/", file), header = FALSE,
stringsAsFactors = FALSE, sep = "\\")
if(nrow(temp)>1) temp = data.frame(V1 = paste(temp$V1, collapse = " "))
cast_data = rbind(cast_data, temp)
}
if(broadcast == "jtbc")
cast_data$year = substr(cast_list, 6, 9)
else cast_data$year = substr(cast_list, 5, 8)
cast_year = cast_data$V1[cast_data$year == year]
cast_text = str_replace_all(cast_year, "[[:lower:]]", " ")
cast_text = str_replace_all(cast_text, "[[:upper:]]", " ")
cast_text = str_replace_all(cast_text, "[^[:alpha:][:digit:]]", " ") # 특수문자 제거
cast_text = str_replace_all(cast_text, "[\u4E00-\u9FD5o]", " ") # 한자 제거
cast_text = str_replace_all(cast_text, "[[:space:]]+", " ")
tmp = lapply(cast_text, function(x) extractNoun(x))
dtm.k2 = DocumentTermMatrix(
VCorpus(VectorSource(tmp)),
control = list(weighting = function(x) weightTfIdf(x, normalize = FALSE))
)
dtm.k2.freq = findMostFreqTerms(dtm.k2)
names(dtm.k2.freq) = NULL
dtm.k2.freq.table = table(names(unlist(dtm.k2.freq)))
dtm.k2.freq.table
})
runApp('first_project')
runApp('first_project')
runApp('first_project')
runApp('first_project')
runApp('first_project')
runApp('first_project')
runApp('first_project')
runApp('first_project')
